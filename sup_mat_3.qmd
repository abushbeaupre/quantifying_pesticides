---
title: "Companion file 3 for: "Towards a principled statistical workflow for the study of wildlife and environmental contaminants in the presence of method detection and quantification limits""
format: html
---

In this document, we will make a function for the prior/posterior predictive checks elaborated in Companion file 2. We want to extend these for cases with multiple pesticides if needed.

```{r}
library(tidyverse)
library(brms)
library(cmdstanr)
library(tidybayes)
library(patchwork)
library(furrr)
library(httpgd)
library(rstan)
hgd()
```


Load model
THIS WILL PROBABLY CHANGE
```{r}
test_long_data <- read_rds(file = "test_long_data.Rda")

dl <- test_long_data %>%
  mutate(lat = as.numeric(lat), lon = as.numeric(lon)) %>%
  rowwise() %>%
  mutate(tot_wat_1 = Water.1000 + Wetland.1000) %>%
  ungroup() %>%
  mutate(scl_water = scale(tot_wat_1),
         year = as.factor(year),
         farm_ID = as.factor(farm_ID),
         pesticide = as.factor(pesticide))

dl_sub <- dl %>%
  mutate(pesticide = as.character(pesticide)) %>%
  filter(!pesticide %in% c("bentazon", "carbaryl", "parathion", "piperonyl.butoxide"))

dl_sub2 <- subset(dl_sub, pesticide != "one.naphthol")

dl_all <- dl %>%
  mutate(pesticide = as.character(pesticide)) %>%
  subset( pesticide != "one.naphthol") %>%
  mutate(pesticide = as.factor(pesticide))

bf_pest_agri_wat_mu_hu <- bf(y_cen | cens(censoring, upper_int) ~ 0 +  
                           pesticide*Comp.1*Comp.2 + 
                           pesticide*Comp.1*scl_water + 
                           (0 +  pesticide | farm_ID) + (1|year) ,
                         hu  ~ 0 +  
                           pesticide*Comp.1*Comp.2 + 
                           pesticide*Comp.1*scl_water + 
                           (0 + pesticide | farm_ID) + (1|year) ,
                         sigma ~ 1 + (1|pesticide) ,
                         family = "hurdle_lognormal")


prior_pest_agri_wat_mu_hu_all <- c(
  # Population effects
  ## mu
  ### Atrazine
  prior(normal(0,2), class = "b", 
        coef = "pesticideatrazine"),
  prior(normal(0,1), class = "b",
        coef = "Comp.1"),
  prior(normal(0,1), class = "b", 
        coef = "Comp.2"),
  prior(normal(0,1), class = "b", 
        coef = "scl_water"),
  prior(normal(0,0.5), class = "b", 
        coef = "Comp.1:Comp.2"),
  prior(normal(0,0.5), class = "b", 
        coef = "Comp.1:scl_water"),
  ### Bentazon
  prior(normal(0,2), class = "b", 
        coef = "pesticidebentazon"),
  prior(normal(0,1), class = "b",
        coef = "pesticidebentazon:Comp.1"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidebentazon:Comp.2"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidebentazon:scl_water"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidebentazon:Comp.1:Comp.2"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidebentazon:Comp.1:scl_water"),
  ### Carbaryl
  prior(normal(0,2), class = "b", 
        coef = "pesticidecarbaryl"),
  prior(normal(0,1), class = "b",
        coef = "pesticidecarbaryl:Comp.1"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidecarbaryl:Comp.2"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidecarbaryl:scl_water"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidecarbaryl:Comp.1:Comp.2"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidecarbaryl:Comp.1:scl_water"),
  ### Clothianidin
  prior(normal(0,2), class = "b", 
        coef = "pesticideclothianidin"),
  prior(normal(0,1), class = "b",
        coef = "pesticideclothianidin:Comp.1"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideclothianidin:Comp.2"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideclothianidin:scl_water"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticideclothianidin:Comp.1:Comp.2"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticideclothianidin:Comp.1:scl_water"),
  ### Imazethapyr
  prior(normal(0,2), class = "b", 
        coef = "pesticideimazethapyr"),
  prior(normal(0,1), class = "b",
        coef = "pesticideimazethapyr:Comp.1"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideimazethapyr:Comp.2"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideimazethapyr:scl_water"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticideimazethapyr:Comp.1:Comp.2"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticideimazethapyr:Comp.1:scl_water"),
  ### Metolachlor
  prior(normal(0,2), class = "b", 
        coef = "pesticidemetolachlor"),
  prior(normal(0,1), class = "b",
        coef = "pesticidemetolachlor:Comp.1"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidemetolachlor:Comp.2"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidemetolachlor:scl_water"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidemetolachlor:Comp.1:Comp.2"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidemetolachlor:Comp.1:scl_water"),
  ### Parathion
  prior(normal(0,2), class = "b", 
        coef = "pesticideparathion"),
  prior(normal(0,1), class = "b",
        coef = "pesticideparathion:Comp.1"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideparathion:Comp.2"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideparathion:scl_water"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticideparathion:Comp.1:Comp.2"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticideparathion:Comp.1:scl_water"),
  ### Piperonyl.butoxide
  prior(normal(0,2), class = "b", 
        coef = "pesticidepiperonyl.butoxide"),
  prior(normal(0,1), class = "b",
        coef = "pesticidepiperonyl.butoxide:Comp.1"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidepiperonyl.butoxide:Comp.2"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidepiperonyl.butoxide:scl_water"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidepiperonyl.butoxide:Comp.1:Comp.2"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidepiperonyl.butoxide:Comp.1:scl_water"),
  ### Thiabendazole
  prior(normal(0,2), class = "b", 
        coef = "pesticidethiabendazole"),
  prior(normal(0,1), class = "b",
        coef = "pesticidethiabendazole:Comp.1"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiabendazole:Comp.2"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiabendazole:scl_water"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidethiabendazole:Comp.1:Comp.2"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidethiabendazole:Comp.1:scl_water"),
  ### Thiacloprid
  prior(normal(0,2), class = "b", 
        coef = "pesticidethiacloprid"),
  prior(normal(0,1), class = "b",
        coef = "pesticidethiacloprid:Comp.1"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiacloprid:Comp.2"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiacloprid:scl_water"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidethiacloprid:Comp.1:Comp.2"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidethiacloprid:Comp.1:scl_water"),
  ### Thiamethoxam
  prior(normal(0,2), class = "b", 
        coef = "pesticidethiamethoxam"),
  prior(normal(0,1), class = "b",
        coef = "pesticidethiamethoxam:Comp.1"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiamethoxam:Comp.2"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiamethoxam:scl_water"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidethiamethoxam:Comp.1:Comp.2"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidethiamethoxam:Comp.1:scl_water"),
  ## hu
  ###Atrazine
  prior(normal(2,1), class = "b", 
        coef = "pesticideatrazine", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "Comp.1", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "Comp.2", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "scl_water", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "Comp.1:Comp.2", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "Comp.1:scl_water", dpar = "hu"),
  ### Bentazon
  prior(normal(2,1), class = "b", 
        coef = "pesticidebentazon", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidebentazon:Comp.1", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidebentazon:Comp.2", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidebentazon:scl_water", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidebentazon:Comp.1:Comp.2", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidebentazon:Comp.1:scl_water", dpar = "hu"),
  ### Carbaryl
  prior(normal(2,1), class = "b", 
        coef = "pesticidecarbaryl", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidecarbaryl:Comp.1", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidecarbaryl:Comp.2", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidecarbaryl:scl_water", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidecarbaryl:Comp.1:Comp.2", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidecarbaryl:Comp.1:scl_water", dpar = "hu"),
  ### Clothianidin
  prior(normal(2,1), class = "b", 
        coef = "pesticideclothianidin", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideclothianidin:Comp.1", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideclothianidin:Comp.2", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideclothianidin:scl_water", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticideclothianidin:Comp.1:Comp.2", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticideclothianidin:Comp.1:scl_water", dpar = "hu"),
  ### Imazethapyr
  prior(normal(2,1), class = "b", 
        coef = "pesticideimazethapyr", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideimazethapyr:Comp.1", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideimazethapyr:Comp.2", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideimazethapyr:scl_water", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticideimazethapyr:Comp.1:Comp.2", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticideimazethapyr:Comp.1:scl_water", dpar = "hu"),
  ### Metolachlor
  prior(normal(2,1), class = "b", 
        coef = "pesticidemetolachlor", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidemetolachlor:Comp.1", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidemetolachlor:Comp.2", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidemetolachlor:scl_water", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidemetolachlor:Comp.1:Comp.2", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidemetolachlor:Comp.1:scl_water", dpar = "hu"),
  ### Parathion
  prior(normal(2,1), class = "b", 
        coef = "pesticideparathion", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideparathion:Comp.1", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideparathion:Comp.2", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticideparathion:scl_water", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticideparathion:Comp.1:Comp.2", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticideparathion:Comp.1:scl_water", dpar = "hu"),
  ### Piperonyl.butoxide
  prior(normal(2,1), class = "b", 
        coef = "pesticidepiperonyl.butoxide", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidepiperonyl.butoxide:Comp.1", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidepiperonyl.butoxide:Comp.2", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidepiperonyl.butoxide:scl_water", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidepiperonyl.butoxide:Comp.1:Comp.2", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidepiperonyl.butoxide:Comp.1:scl_water", dpar = "hu"),
  ### Thiabendazole
  prior(normal(2,1), class = "b", 
        coef = "pesticidethiabendazole", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiabendazole:Comp.1", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiabendazole:Comp.2", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiabendazole:scl_water", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidethiabendazole:Comp.1:Comp.2", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidethiabendazole:Comp.1:scl_water", dpar = "hu"),
  ### Thiacloprid
  prior(normal(2,1), class = "b", 
        coef = "pesticidethiacloprid", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiacloprid:Comp.1", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiacloprid:Comp.2", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiacloprid:scl_water", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidethiacloprid:Comp.1:Comp.2", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidethiacloprid:Comp.1:scl_water", dpar = "hu"),
  ### Thiamethoxam
  prior(normal(2,1), class = "b", 
        coef = "pesticidethiamethoxam", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiamethoxam:Comp.1", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiamethoxam:Comp.2", dpar = "hu"),
  prior(normal(0,1), class = "b", 
        coef = "pesticidethiamethoxam:scl_water", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidethiamethoxam:Comp.1:Comp.2", dpar = "hu"),
  prior(normal(0,0.5), class = "b", 
        coef = "pesticidethiamethoxam:Comp.1:scl_water", dpar = "hu"),
  
  # Sigma
  prior(normal(-1,1), class = "Intercept", dpar = "sigma"),
  # Hierarchical effects
  prior(exponential(2), class = "sd"),
  prior(exponential(3), class = "sd", dpar = "hu"),
  prior(exponential(3), class = "sd", dpar = "sigma"),
  prior(lkj(2), class = "cor")
)

mod_pest_agri_wat_mu_hu_all <- brm(data = dl_all,
           formula = bf_pest_agri_wat_mu_hu ,
           prior = prior_pest_agri_wat_mu_hu_all ,
           iter = 15000, warmup = 2000, chains = 4, cores = 4,
           threads = threading(4, grainsize = 100),
           backend = "cmdstanr",
           control = list(adapt_delta = 0.99),
           file = "mod_pest_agri_wat_mu_hu_all")


```

Simulated data

```{r}
set.seed(333)
calculate_a_lnorm <- function(mean, sd){

  log(mean^2/sqrt(sd^2 + mean^2))

}


calculate_b_lnorm <- function(mean, sd){

  sqrt(log(sd^2 / mean^2 + 1))

}

# Set simulation parameters
n <- 2000          # Number of samples
mean_resp <- 0.23  # Average on reponse scale
sd_resp <- 0.06    # Standard devation on reponse scale
p_zeros <- 0.1     # Probability of zero
# Expected average including presence probability
expected_resp <- mean_resp * (1 - p_zeros) 
LOD <- 0.15        # Limit of detection
LOQ <- 0.19        # Limit of quantification
# Calculate a and b parameters of lognormal distribution
a <- calculate_a_lnorm(mean_resp, sd_resp)
b <- calculate_b_lnorm(mean_resp, sd_resp)
# Generate simulated data
tibble(
  # Generate lognormal concentrations
  conc = round(rlnorm(n, a, b),2),  
  # Presence probability of 0.9
  zeros = rbinom(n, prob = (1 - p_zeros), size = 1),  
  # Final concentrations (including zeros)
  Y = conc * zeros,
  contaminant = "Fake")  |>
  mutate(
    # format data
    y_cen = case_when(
    # Set values below LOD to LOD
      Y < LOD ~ LOD,  
    # Set values between LOD and LOQ to LOD
      Y >= LOD & Y < LOQ ~ LOD,  
    # Leave other values as is
      TRUE ~ Y),  
    # Create column for upper bound of interval censoring
    upper_int_cens = ifelse(Y >= LOD & Y < LOQ, LOQ, Y), 
    # Create column for censoring type
    censoring = case_when(
    # Left-censored
      Y < LOD ~ "left",  
    # Interval-censored
      Y >= LOD & Y < LOQ ~ "interval",  
    # Fully observed
      TRUE ~ "none")  
) -> censored_data


bf_intercept <- bf(y_cen | cens(censoring , upper_int_cens) ~ 1, 
                                                         hu ~ 1, 
                           family = hurdle_lognormal(link = "identity", 
                                                     link_sigma = "log", 
                                                     link_hu = "logit")
)

mod_intercept <- brms::brm(formula = bf_intercept,
                 data = censored_data,
                 iter = 500, warmup = 100, chains = 4, cores = 4,
                 seed = 333,
                 threads = threading(4, grainsize = 100),
                 backend = "cmdstanr")
```



We will build the function piece by piece

Function to generate predictions, bin them by censoring category

```{r}
ppc_predict <- function(data,            # Data used in model
                        model,           # model
                        draws = 100,     # number of posterior draws
                        re_form          # Hierarchical effects included
                        ) {

data |>
    # add predicted obervations
    tidybayes::add_predicted_draws(model, ndraws = draws, re_formula = re_form) |> 
    # creates a grouped tibble so we need to ungroup
    ungroup() |>
    # now we bin values into < LOD, > LOD <= LOQ, and quantified
    mutate(
    pred_type = factor(
      case_when(
    # Left-censored
      .prediction < LOD ~ "left",  
    # Interval-censored
      .prediction  >= LOD & .prediction  < LOQ ~ "interval",    
    # Fully observed
      TRUE ~ "none"),
      levels = c("left", "interval", "none")) )
}

# test
test_pred <- ppc_predict(data = dl_all, 
                        model = mod_pest_agri_wat_mu_hu_all, 
                        draws = 2,
                        re_form = ~ (0 +  pesticide | farm_ID) + (1|year) + (1|pesticide))
```

We will make separate functions for each type of plot

Density plot 

Test function
THIS IS NOT GOOD - use only for example for function below
```{r}
# Set up parallel processing
plan(multisession)

# Modified density plot function
dens_plot <- function(binned_obs, binned_preds, data, predictions, limits = FALSE) {
  # Get unique pesticides
  pesticides <- unique(data$pesticide)
  
  # Create and collect plots for each pesticide in parallel
  plot_list <- future_map(pesticides, function(pest) {
    # Filter data for current pesticide
    obs_pest <- binned_obs |> filter(pesticide == pest)
    preds_pest <- binned_preds |> filter(pesticide == pest)
    data_pest <- data |> filter(pesticide == pest)
    pred_pest <- predictions |> filter(pesticide == pest)
    
    # Create categorical plot
    plot_cat <- ggplot() + 
      geom_col(data = obs_pest, aes(x = censoring, y = n), fill = "darkblue") + 
      stat_pointinterval(data = preds_pest, aes(x = pred_type, y = n), 
                        color = "lightblue", size = 1) + 
      theme_classic() +
      labs(x = NULL, y = "n observations")

    # Create quantitative plot
    plot_quant <- ggplot() +
      geom_density(data = pred_pest |> filter(pred_type == "none"), 
                  aes(x = .prediction, group = .draw), color = "lightblue", 
                  trim = TRUE) +
      geom_density(data = data_pest |> filter(censoring == "none"), 
                  aes(x = y_cen), color = "darkblue", linewidth = 1, 
                  trim = TRUE) +
      theme_classic() + 
      labs(x = "quantified values")

    # Add limits if specified
    if(limits == TRUE) {
      plot_quant <- plot_quant + 
        coord_cartesian(xlim = c(0, max(data_pest$y_cen[data_pest$censoring == "none"], 
                                      na.rm = TRUE)))
    }
    
    # Combine plots and add title
    combined_plot <- plot_cat + plot_quant + 
      plot_layout(widths = c(1, 3)) + 
      plot_annotation(title = pest)
    
    return(combined_plot)
  })
  
  # Clean up parallel processing
  plan(sequential)
  
  # Print plots sequentially
  walk(plot_list, print)
}

# Usage example:
dens_plot(binned_obs = binned_obs_test,
          binned_preds = binned_preds_test, 
          data = dl_all,
          predictions = test_pred,
          limits = TRUE)
```

Density function, piece-by-piece
Binned observations & predictions
```{r}
binned_by_cont <- function(data,            # Data used in model
                           preds,           # Model predictions generated by ppc_predict()
                           cont_col,        # Column for contaminant ID
                           cens_col         # Column specifying censoring type in data
                           ) {
  # Bin predictions     
  binned_preds <- preds |>
      group_by({{ cont_col }}, .draw) |>
      count(pred_type) |>
      ungroup()

  # Bin observations
  binned_obs <- data |>
      mutate( {{ cens_col }} := factor( {{ cens_col }}, levels = c("left", "interval", "none"))) |>
      group_by({{ cont_col }}) |>
      count({{ cens_col }}) |>
      ungroup()

 print(binned_preds)
 print(binned_obs)
}

# test
binned_by_cont(data = dl_all, preds = test_pred, cont_col = pesticide, cens_col = censoring)
```

Add plots

```{r}
binned_plots_by_cont <- function(data,            # Data used in model
                                 preds,           # Model predictions generated by ppc_predict()
                                 cont_col,        # Column for contaminant ID
                                 cens_col,        # Column specifying censoring type in data
                                 y,               # Column specifying (censored) observations in data
                                 limits = FALSE   # Crop plots to maximum of observed value?
                           ) {
  # Bin predictions     
  binned_preds <- preds |>
      group_by({{ cont_col }}, .draw) |>
      count(pred_type) |>
      ungroup()

  # Bin observations
  binned_obs <- data |>
      mutate( {{ cens_col }} := factor( {{ cens_col }}, levels = c("left", "interval", "none"))) |>
      group_by({{ cont_col }}) |>
      count({{ cens_col }}) |>
      ungroup()
 
  # Get unique pesticides
  contaminants <- unique(data |> pull({{ cont_col }}))

  # Set up parallel processing
  plan(multisession)
  
  # Create and collect plots for each contaminant in parallel
  plot_list <- future_map(contaminants, function(cont) {
      # Filter data for current pesticide
      binned_obs_cont <- binned_obs |> filter({{ cont_col }} == cont)
      binned_preds_cont <- binned_preds |> filter({{ cont_col }} == cont)
      data_cont <- data |> filter({{ cont_col }} == cont)
      pred_cont <- preds |> filter({{ cont_col }} == cont)
      
      # Create categorical plot
      plot_cat <- ggplot() + 
        geom_col(data = binned_obs_cont, 
                   aes(x = {{ cens_col }}, y = n), 
                   fill = "darkblue") + 
        stat_pointinterval(data = binned_preds_cont, 
                             aes(x = pred_type, y = n), 
                             color = "lightblue", size = 1) + 
        theme_classic() +
        labs(x = NULL, y = "n observations")

      # Create quantitative plot
      plot_quant <- ggplot() +
        geom_density(data = pred_cont |> filter(pred_type == "none"), 
                          aes(x = .prediction, group = .draw), color = "lightblue", 
                          trim = TRUE) +
        geom_density(data = data_cont |> filter({{ cens_col }} == "none"), 
                          aes(x = {{ y }}), color = "darkblue", linewidth = 1, 
                          trim = TRUE) +
        theme_classic() + 
        labs(x = "quantified values")

      # Add limits if specified
      if(limits == TRUE) {
        plot_quant <- plot_quant + 
            coord_cartesian(xlim = c(0, max(data_cont |> 
                                            pull({{ y }}), 
                                            na.rm = TRUE)))
      }
      
      # Combine plots and add title
      combined_plot <- plot_cat + plot_quant + 
        plot_layout(widths = c(1, 3)) + 
        plot_annotation(title = paste(cont))
      
      return(combined_plot)
  })
  
  # Clean up parallel processing
  plan(sequential)
  
  # Print plots sequentially
  walk(plot_list, print)
}

# Test 
binned_plots_by_cont(data = dl_all, preds = test_pred, cont_col = "pesticide", cens_col = "censoring", y = "y_cen")
```

Copilot suggestion:
GOOD
```{r}
binned_plots_by_cont2 <- function(data,            # Data used in model
                                 preds,           # Model predictions generated by ppc_predict()
                                 cont_col,        # Column for contaminant ID
                                 cens_col,        # Column specifying censoring type in data
                                 y,               # Column specifying (censored) observations in data
                                 limits = FALSE   # Crop plot to the limit of observed data?
                           ) {
  # Bin predictions     
  binned_preds <- preds |>
      group_by(!!sym(cont_col), .draw) |>
      count(pred_type) |>
      ungroup()

  # Bin observations
  binned_obs <- data |>
      mutate(!!sym(cens_col) := factor(!!sym(cens_col), levels = c("left", "interval", "none"))) |>
      group_by(!!sym(cont_col)) |>
      count(!!sym(cens_col)) |>
      ungroup()
 
  # Get unique contaminants
  contaminants <- unique(data %>% pull(!!sym(cont_col)))

  # Set up parallel processing
  plan(multisession)
  
  # Create and collect plots for each contaminant in parallel
  plot_list <- future_map(contaminants, function(cont) {
      # Filter data for current contaminant
      binned_obs_cont <- binned_obs |> filter(!!sym(cont_col) == cont)
      binned_preds_cont <- binned_preds |> filter(!!sym(cont_col) == cont)
      data_cont <- data |> filter(!!sym(cont_col) == cont)
      pred_cont <- preds |> filter(!!sym(cont_col) == cont)
      
      # Create categorical plot
      plot_cat <- ggplot() + 
        geom_col(data = binned_obs_cont, 
                   aes(x = !!sym(cens_col), y = n), 
                   fill = "darkblue") + 
        stat_pointinterval(data = binned_preds_cont, 
                             aes(x = pred_type, y = n), 
                             color = "lightblue", size = 1) + 
        theme_classic() +
        labs(x = NULL, y = "n observations")

      # Create quantitative plot
      plot_quant <- ggplot() +
        geom_density(data = pred_cont |> filter(pred_type == "none"), 
                          aes(x = .prediction, group = .draw), color = "lightblue", 
                          trim = TRUE) +
        geom_density(data = data_cont |> filter(!!sym(cens_col) == "none"), 
                          aes(x = !!sym(y)), color = "darkblue", linewidth = 1, 
                          trim = TRUE) +
        theme_classic() + 
        labs(x = "quantified values")

      # Add limits if specified
      if(limits == TRUE) {
        plot_quant <- plot_quant + 
            coord_cartesian(xlim = c(0, max(data_cont |> 
                                            pull(!!sym(y)), 
                                            na.rm = TRUE)))
      }
      
      # Combine plots and add title
      combined_plot <- plot_cat + plot_quant + 
        plot_layout(widths = c(1, 3)) + 
        plot_annotation(title = paste(cont))
      
      return(combined_plot)
  })
  
  # Clean up parallel processing
  plan(sequential)
  
  # Print plots sequentially
  walk(plot_list, print)
}

# Test 
binned_plots_by_cont2(data = dl_all, preds = test_pred, cont_col = "pesticide", cens_col = "censoring", y = "y_cen")
```

Try with model for single pesticide

```{r}
pred_single <- ppc_predict(data = censored_data, 
                        model = mod_intercept, 
                        draws = 2,
                        re_form = NA)

binned_plots_by_cont2(data = censored_data, preds = pred_single, cont_col = "contaminant", cens_col = "censoring", y = "y_cen")
```

```{r}
ggplot() +
    geom_vline(data = censored_data |> 
                      filter(censoring == "none") |>
                      summarise(perc_95 = quantile(y_cen, 0.95)),
    aes(xintercept = perc_95), 
    linewidth = 1, 
    color = "darkblue") +
    stat_pointinterval(data = predicted_values |> 
                              filter(pred_type == "none") |>
                              group_by(.draw) |>
                              summarise(perc_95 = quantile(y_cen, 0.95)) |>
                              ungroup(), 
                       aes(x = perc_95), 
                       color = "lightblue")
```


Function for single pesticide

```{r}
binned_plot_1_cont <- function(data, preds, cens_col, y, limits = FALSE){
  # Bin predictions     
  binned_preds <- preds |>
      group_by( .draw) |>
      count(pred_type) |>
      ungroup()

  # Bin observations
  binned_obs <- data |>
      mutate(!!sym(cens_col) := factor(!!sym(cens_col), levels = c("left", "interval", "none"))) |>
      count(!!sym(cens_col))


  # Create categorical plot
      plot_cat <- ggplot() + 
        geom_col(data = binned_obs, 
                   aes(x = !!sym(cens_col), y = n), 
                   fill = "darkblue") + 
        stat_pointinterval(data = binned_preds, 
                             aes(x = pred_type, y = n), 
                             color = "lightblue", size = 1) + 
        theme_classic() +
        labs(x = NULL, y = "n observations")

  # Create quantitative plot
      plot_quant <- ggplot() +
        geom_density(data = preds |> filter(pred_type == "none"), 
                          aes(x = .prediction, group = .draw), color = "lightblue", 
                          trim = TRUE) +
        geom_density(data = data |> filter(!!sym(cens_col) == "none"), 
                          aes(x = !!sym(y)), color = "darkblue", linewidth = 1, 
                          trim = TRUE) +
        theme_classic() + 
        labs(x = "quantified values")

  # Add limits if specified
      if(limits == TRUE) {
        plot_quant <- plot_quant + 
            coord_cartesian(xlim = c(0, max(data |> 
                                            pull(!!sym(y)), 
                                            na.rm = TRUE)))
      }
      
      # Combine plots and add title
      combined_plot <- plot_cat + plot_quant + 
        plot_layout(widths = c(1, 3)) 
      
      return(combined_plot)
}

# test
pred_single <- ppc_predict(data = censored_data, 
                        model = mod_intercept, 
                        draws = 2,
                        re_form = NA)

binned_plot_1_cont(data = censored_data, preds = pred_single, cens_col = "censoring", y = "y_cen")
```

Bring it all together

```{r}
cens_dens <- function(data,            # Data used in model
                      preds,           # Model predictions generated by ppc_predict()
                      cont_col,        # Column for contaminant ID
                      cens_col,        # Column specifying censoring type in data
                      by_cont = TRUE,  # Plot by contaminant?
                      y,               # Column specifying (censored) observations in data
                      limits = FALSE   # Crop plot to the limit of observed data?)
) { # Opening function block
 
 if(by_cont == TRUE){ # if multiple contaminants
 # Bin predictions     
  binned_preds <- preds |>
      group_by(!!sym(cont_col), .draw) |>
      count(pred_type) |>
      ungroup()

  # Bin observations
  binned_obs <- data |>
      mutate(!!sym(cens_col) := factor(!!sym(cens_col), levels = c("left", "interval", "none"))) |>
      group_by(!!sym(cont_col)) |>
      count(!!sym(cens_col)) |>
      ungroup()
 
  # Get unique contaminants
  contaminants <- unique(data |> pull(!!sym(cont_col)))

  # Set up parallel processing
  plan(multisession)
  
  # Create and collect plots for each contaminant in parallel
  plot_list <- future_map(contaminants, function(cont) {
      # Filter data for current contaminant
      binned_obs_cont <- binned_obs |> filter(!!sym(cont_col) == cont)
      binned_preds_cont <- binned_preds |> filter(!!sym(cont_col) == cont)
      data_cont <- data |> filter(!!sym(cont_col) == cont)
      pred_cont <- preds |> filter(!!sym(cont_col) == cont)
      
      # Create categorical plot
      plot_cat <- ggplot() + 
        geom_col(data = binned_obs_cont, 
                   aes(x = !!sym(cens_col), y = n), 
                   fill = "darkblue") + 
        stat_pointinterval(data = binned_preds_cont, 
                             aes(x = pred_type, y = n), 
                             color = "lightblue", size = 1) + 
        theme_classic() +
        labs(x = NULL, y = "n observations")

      # Create quantitative plot
      plot_quant <- ggplot() +
        geom_density(data = pred_cont |> filter(pred_type == "none"), 
                          aes(x = .prediction, group = .draw), color = "lightblue", 
                          trim = TRUE) +
        geom_density(data = data_cont |> filter(!!sym(cens_col) == "none"), 
                          aes(x = !!sym(y)), color = "darkblue", linewidth = 1, 
                          trim = TRUE) +
        theme_classic() + 
        labs(x = "quantified values")

      # Add limits if specified
      if(limits == TRUE) {
        plot_quant <- plot_quant + 
            coord_cartesian(xlim = c(0, max(data_cont |> 
                                            pull(!!sym(y)), 
                                            na.rm = TRUE)))
      }
      
      # Combine plots and add title
      combined_plot <- plot_cat + plot_quant + 
        plot_layout(widths = c(1, 3)) + 
        plot_annotation(title = paste(cont))
      
      return(combined_plot)
  })
  
  # Clean up parallel processing
  plan(sequential)
  
  # Print plots sequentially
  walk(plot_list, print)


 } else { # If only one contaminant
  
  # Bin predictions     
  binned_preds <- preds |>
      group_by(.draw) |>
      count(pred_type) |>
      ungroup()

  # Bin observations
  binned_obs <- data |>
      mutate(!!sym(cens_col) := factor(!!sym(cens_col), levels = c("left", "interval", "none"))) |>
      count(!!sym(cens_col))


  # Create categorical plot
      plot_cat <- ggplot() + 
        geom_col(data = binned_obs, 
                   aes(x = !!sym(cens_col), y = n), 
                   fill = "darkblue") + 
        stat_pointinterval(data = binned_preds, 
                             aes(x = pred_type, y = n), 
                             color = "lightblue", size = 1) + 
        theme_classic() +
        labs(x = NULL, y = "n observations")

  # Create quantitative plot
      plot_quant <- ggplot() +
        geom_density(data = preds |> filter(pred_type == "none"), 
                          aes(x = .prediction, group = .draw), color = "lightblue", 
                          trim = TRUE) +
        geom_density(data = data |> filter(!!sym(cens_col) == "none"), 
                          aes(x = !!sym(y)), color = "darkblue", linewidth = 1, 
                          trim = TRUE) +
        theme_classic() + 
        labs(x = "quantified values")

  # Add limits if specified
      if(limits == TRUE) {
        plot_quant <- plot_quant + 
            coord_cartesian(xlim = c(0, max(data |> 
                                            pull(!!sym(y)), 
                                            na.rm = TRUE)))
      }
      
  # Combine plots
      combined_plot <- plot_cat + plot_quant + 
        plot_layout(widths = c(1, 3)) 
      
      return(combined_plot)

 } # Close else block

} # Close function
```






Copilot suggestion:

```{r}
cens_dens <- function(data,            # Data used in model
                      preds,           # Model predictions generated by ppc_predict()
                      cont_col,        # Column for contaminant ID
                      cens_col,        # Column specifying censoring type in data
                      by_cont = TRUE,  # Plot by contaminant?
                      y,               # Column specifying (censored) observations in data
                      limits = FALSE   # Crop plot to the limit of observed data?
) { # Opening function block
 
 if(by_cont == TRUE){ # if multiple contaminants
   # Bin predictions     
   binned_preds <- preds %>%
       group_by(!!sym(cont_col), .draw) %>%
       count(pred_type) %>%
       ungroup()

   # Bin observations
   binned_obs <- data %>%
       mutate(!!sym(cens_col) := factor(!!sym(cens_col), levels = c("left", "interval", "none"))) %>%
       group_by(!!sym(cont_col)) %>%
       count(!!sym(cens_col)) %>%
       ungroup()
 
   # Get unique contaminants
   contaminants <- unique(data %>% pull(!!sym(cont_col)))

   # Set up parallel processing
   plan(multisession)
  
   # Create and collect plots for each contaminant in parallel
   plot_list <- future_map(contaminants, function(cont) { # Opening future_map block
       # Filter data for current contaminant
       binned_obs_cont <- binned_obs %>% filter(!!sym(cont_col) == cont)
       binned_preds_cont <- binned_preds %>% filter(!!sym(cont_col) == cont)
       data_cont <- data %>% filter(!!sym(cont_col) == cont)
       pred_cont <- preds %>% filter(!!sym(cont_col) == cont)
      
       # Create categorical plot
       plot_cat <- ggplot() + 
         geom_col(data = binned_obs_cont, 
                    aes(x = !!sym(cens_col), y = n), 
                    fill = "darkblue") + 
         stat_pointinterval(data = binned_preds_cont, 
                              aes(x = pred_type, y = n), 
                              color = "lightblue", size = 1) + 
         theme_classic() +
         labs(x = NULL, y = "n observations")

       # Create quantitative plot
       plot_quant <- ggplot() +
         geom_density(data = pred_cont %>% filter(pred_type == "none"), 
                           aes(x = .prediction, group = .draw), color = "lightblue", 
                           trim = TRUE) +
         geom_density(data = data_cont %>% filter(!!sym(cens_col) == "none"), 
                           aes(x = !!sym(y)), color = "darkblue", linewidth = 1, 
                           trim = TRUE) +
         theme_classic() + 
         labs(x = "quantified values")

       # Add limits if specified
       if(limits == TRUE) { # Opening if block
         plot_quant <- plot_quant + 
             coord_cartesian(xlim = c(0, max(data_cont %>% 
                                             pull(!!sym(y)), 
                                             na.rm = TRUE)))
       } # Closing if block
        
       # Combine plots and add title
       combined_plot <- plot_cat + plot_quant + 
         plot_layout(widths = c(1, 3)) + 
         plot_annotation(title = paste(cont))
        
       return(combined_plot)
   }) # Closing future_map block
    
   # Clean up parallel processing
   plan(sequential)
    
   # Print plots sequentially
   walk(plot_list, print)

 } else { # If only one contaminant

   # Bin predictions     
   binned_preds <- preds %>%
       group_by(.draw) %>%
       count(pred_type) %>%
       ungroup()

   # Bin observations
   binned_obs <- data %>%
       mutate(!!sym(cens_col) := factor(!!sym(cens_col), levels = c("left", "interval", "none"))) %>%
       count(!!sym(cens_col))
        
   # Create categorical plot
   plot_cat <- ggplot() + 
         geom_col(data = binned_obs, 
                    aes(x = !!sym(cens_col), y = n), 
                    fill = "darkblue") + 
         stat_pointinterval(data = binned_preds, 
                              aes(x = pred_type, y = n), 
                              color = "lightblue", size = 1) + 
         theme_classic() +
         labs(x = NULL, y = "n observations")

   # Create quantitative plot
   plot_quant <- ggplot() +
         geom_density(data = preds %>% filter(pred_type == "none"), 
                           aes(x = .prediction, group = .draw), color = "lightblue", 
                           trim = TRUE) +
         geom_density(data = data %>% filter(!!sym(cens_col) == "none"), 
                           aes(x = !!sym(y)), color = "darkblue", linewidth = 1, 
                           trim = TRUE) +
         theme_classic() + 
         labs(x = "quantified values")

   # Add limits if specified
   if(limits == TRUE) { # Opening if block
     plot_quant <- plot_quant + 
         coord_cartesian(xlim = c(0, max(data %>% 
                                         pull(!!sym(y)), 
                                         na.rm = TRUE)))
   } # Closing if block
    
   # Combine plots
   combined_plot <- plot_cat + plot_quant + 
     plot_layout(widths = c(1, 3)) 
      
   return(combined_plot)

 } # Closing else block

} # Closing function block
```


Copilot suggestion:

```{r}
cens_dens <- function(data,            # Data used in model
                      preds,           # Model predictions generated by ppc_predict()
                      cont_col,        # Column for contaminant ID
                      cens_col,        # Column specifying censoring type in data
                      by_cont = TRUE,  # Plot by contaminant?
                      y,               # Column specifying (censored) observations in data
                      limits = FALSE   # Crop plot to the limit of observed data?
) { # Opening function block
 
 if(by_cont == TRUE){ # if multiple contaminants
   # Bin predictions     
   binned_preds <- preds %>%
       group_by(!!sym(cont_col), .draw) %>%
       count(pred_type) %>%
       ungroup()

   # Bin observations
   binned_obs <- data %>%
       mutate(!!sym(cens_col) := factor(!!sym(cens_col), levels = c("left", "interval", "none"))) %>%
       group_by(!!sym(cont_col)) %>%
       count(!!sym(cens_col)) %>%
       ungroup()
 
   # Get unique contaminants
   contaminants <- unique(data %>% pull(!!sym(cont_col)))

   # Set up parallel processing
   plan(multisession)
  
   # Create and collect plots for each contaminant in parallel
   plot_list <- future_map(contaminants, function(cont) { # Opening future_map block
       # Filter data for current contaminant
       binned_obs_cont <- binned_obs %>% filter(!!sym(cont_col) == cont)
       binned_preds_cont <- binned_preds %>% filter(!!sym(cont_col) == cont)
       data_cont <- data %>% filter(!!sym(cont_col) == cont)
       pred_cont <- preds %>% filter(!!sym(cont_col) == cont)
      
       # Create categorical plot
       plot_cat <- ggplot() + 
         geom_col(data = binned_obs_cont, 
                    aes(x = !!sym(cens_col), y = n), 
                    fill = "darkblue") + 
         stat_pointinterval(data = binned_preds_cont, 
                              aes(x = pred_type, y = n), 
                              color = "lightblue", size = 1) + 
         theme_classic() +
         labs(x = NULL, y = "n observations")

       # Create quantitative plot
       plot_quant <- ggplot() +
         geom_density(data = pred_cont %>% filter(pred_type == "none"), 
                           aes(x = .prediction, group = .draw), color = "lightblue", 
                           trim = TRUE) +
         geom_density(data = data_cont %>% filter(!!sym(cens_col) == "none"), 
                           aes(x = !!sym(y)), color = "darkblue", linewidth = 1, 
                           trim = TRUE) +
         theme_classic() + 
         labs(x = "quantified values")

       # Add limits if specified
       if(limits == TRUE) { # Opening if block
         plot_quant <- plot_quant + 
             coord_cartesian(xlim = c(0, max(data_cont %>% 
                                             pull(!!sym(y)), 
                                             na.rm = TRUE)))
       } # Closing if block
        
       # Combine plots and add title
       combined_plot <- plot_cat + plot_quant + 
         plot_layout(widths = c(1, 3)) + 
         plot_annotation(title = paste(cont))
        
       return(combined_plot)
   }) # Closing future_map block
    
   # Clean up parallel processing
   plan(sequential)
    
   # Print plots sequentially
   walk(plot_list, print)

 } else { # If only one contaminant

   # Bin predictions     
   binned_preds <- preds %>%
       group_by(.draw) %>%
       count(pred_type) %>%
       ungroup()

   # Bin observations
   binned_obs <- data %>%
       mutate(!!sym(cens_col) := factor(!!sym(cens_col), levels = c("left", "interval", "none"))) %>%
       count(!!sym(cens_col))
        
   # Create categorical plot
   plot_cat <- ggplot() + 
         geom_col(data = binned_obs, 
                    aes(x = !!sym(cens_col), y = n), 
                    fill = "darkblue") + 
         stat_pointinterval(data = binned_preds, 
                              aes(x = pred_type, y = n), 
                              color = "lightblue", size = 1) + 
         theme_classic() +
         labs(x = NULL, y = "n observations")

   # Create quantitative plot
   plot_quant <- ggplot() +
         geom_density(data = preds %>% filter(pred_type == "none"), 
                           aes(x = .prediction, group = .draw), color = "lightblue", 
                           trim = TRUE) +
         geom_density(data = data %>% filter(!!sym(cens_col) == "none"), 
                           aes(x = !!sym(y)), color = "darkblue", linewidth = 1, 
                           trim = TRUE) +
         theme_classic() + 
         labs(x = "quantified values")

   # Add limits if specified
   if(limits == TRUE) { # Opening if block
     plot_quant <- plot_quant + 
         coord_cartesian(xlim = c(0, max(data %>% 
                                         pull(!!sym(y)), 
                                         na.rm = TRUE)))
   } # Closing if block
    
   # Combine plots
   combined_plot <- plot_cat + plot_quant + 
     plot_layout(widths = c(1, 3)) 
      
   return(combined_plot)

 } # Closing else block

} # Closing function block

# Test 
cens_dens(data = dl_all, preds = test_pred, cont_col = "pesticide", cens_col = "censoring", y = "y_cen")
```
